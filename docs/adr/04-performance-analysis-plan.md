# 성능 분석 설계

Date: 2025-10-08
Status: Accepted

## 맥락

프로젝트의 성능을 향상시키기 위해서는 **“측정 → 분석 → 개선 → 검증”** 의 반복적인 사이클이 필요합니다.  
현재는 랜덤 데이터 기반의 테스트 환경으로 인해 결과가 일관되지 않고, 성능 변화의 신뢰성이 낮은 상태입니다.  
이에 따라 **테스트 환경의 멱등성 확보**, **세분화된 프로파일링**, **데이터 시각화**, **가설 기반 개선 전략 수립**의 4단계로 나누어 접근합니다.

## 결정

### 1단계: 멱등성 확보 - 일관성 있는 테스트 환경 구축

- **목표** : 동일 입력(seed)에 대해 항상 동일한 결과를 생성
- **핵심 조치** : Seed 기반 랜덤 생성기 도입 / 벤치마크 데이터셋 사전 생성

#### ① Seed 기반 PRNG 적용

- `Math.random()` 대신 **Seed 기반 PRNG (예: seedrandom)**
- `src/domain/scenario/generator.ts` 내 `createInitialGraph(seed)` 형태로 수정
- 동일한 seed → 동일한 그래프(노드, 엣지, 그룹) 생성 → 신뢰 가능한 비교 가능

  > PRNG : Pseudorandom Number Generator

- **대안 1.** : 벤치마크 데이터셋 생성
  - 대표 시나리오(예: 120노드/180엣지/4그룹) 10~20개 사전 생성
  - Graph 객체를 JSON으로 저장하여 회귀 테스트(Regression Test)에 활용 가능
- **대안 2.** : PRNG를 위한 LCG 직접 구현

#### ③ 테스트 시나리오 정의

| 시나리오명       | 노드 수 | 엣지 수 | 그룹 수 | 목적             |
| ---------------- | ------- | ------- | ------- | ---------------- |
| Small            | 12      | 18      | 2       | 빠른 피드백      |
| Medium           | 60      | 90      | 3       | 일반적인 케이스  |
| Large (Standard) | 120     | 180     | 4       | 기본 기준        |
| High-Density     | 60      | 180     | 3       | 엣지 밀도 테스트 |
| Many-Groups      | 120     | 180     | 10      | 그룹 부하 테스트 |

> 우선 Large 까지만 구성 후 필요 시 향후 확장

<br/>
<br/>

---

<br/>
<br/>

### 2단계: 세분화된 성능 프로파일링 (병목 지점 식별)

- **목표** : 파이프라인별 시간 분해 측정으로 병목 모듈 식별
- **핵심 조치** : profiler 유틸리티 구현 및 각 모듈 삽입

#### ① Profiler 유틸리티 설계

- `src/utils/profiler.ts` 생성
- `performance.now()` 기반으로 `start(name)` / `stop(name)` 메서드 구현
- 결과는 `Map<string, number>` 형태로 저장 → `getResults()`로 JSON 반환

#### ② 모듈별 측정 코드 삽입 예시

```typescript
// LegacyAStarStrategy.ts
public execute(graph: Graph, cfg: any): Graph {
  profiler.start('initialPlacement');
  graph = initialPlacement(graph, cfg);
  profiler.stop('initialPlacement');

  profiler.start('resolveOverlap');
  graph = resolveOverlap(graph, cfg);
  profiler.stop('resolveOverlap');

  return graph;
}
```

#### ③ 주요 측정 대상 모듈

| 구분          | 모듈명                                                                              | 설명                       |
| ------------- | ----------------------------------------------------------------------------------- | -------------------------- |
| 공통          | `initialPlacement`, `resolveOverlap`, `sweepCompact`, `assignPorts`, `beautifyPath` | 공통 파이프라인            |
| A\* 전략      | `buildGrid`, `aStarGrid`                                                            | 엣지별 반복 처리 병목 가능 |
| Bus 전략      | `createBusChannels`, `buildBusNetworkGraph`, `routeEdgesOnBus`                      | 주요 병목 지점             |
| Vertices 전략 | `createRoutingVertices`, `buildVisibilityGraph`, `routeOnVisibilityGraph`           | 그래프 생성 및 탐색        |

<br/>
<br/>

---

<br/>
<br/>

### 3단계: 데이터 수집 및 시각화 (결과 분석)

- **목표** : 측정 결과를 수집·정량화하여 병목 구간 가시화
- **핵심 조치** : 자동화된 프로파일링 스크립트 및 통계 분석

#### ① 데이터 수집 자동화

- 여러 시나리오 × 전략 × seed 조합으로 반복 실행
- 각 실행 결과를 JSON으로 저장 (/data/profiling-results/)

#### ② 데이터 분석

| 항목                     | 설명                       |
| ------------------------ | -------------------------- |
| 평균 / 중앙값 / 표준편차 | 일반적 성능 및 안정성 평가 |
| 최소 / 최대              | 극단적 케이스 탐지         |
| 분포 분석                | 알고리즘의 일관성 검증     |

#### ③ 시각화 방안

| 시각화 방식                      | 목적                                                   |
| -------------------------------- | ------------------------------------------------------ |
| **파이 차트 / 누적 막대 그래프** | 전체 수행 시간 대비 모듈별 비중                        |
| **박스 플롯(Box Plot)**          | 전략별 실행 결과 분포 비교                             |
| **라인 그래프**                  | 노드/엣지 수 대비 수행 시간 → 확장성(Scalability) 분석 |

<br/>
<br/>

---

<br/>
<br/>

### 4단계: 가설 수립 및 개선 계획 도출

- **목표** : 데이터 기반으로 성능 저하 원인 규명 및 개선
- **핵심 조치** : 가설 설정 → 코드 분석 → 알고리즘 개선 → 재검증

#### 프로세스 예시

| 단계       | 내용                                                                     |
| ---------- | ------------------------------------------------------------------------ |
| **관찰**   | Bus Channel 전략의 `createBusChannels()`이 전체의 80% (4초) 차지         |
| **가설**   | 내부 알고리즘의 복잡도가 O(n³)에 가까워 노드 수 증가 시 급격한 성능 저하 |
| **검증**   | 코드 리뷰 및 복잡도 분석을 통해 병목 구간 확인                           |
| **개선**   | 공간 분할(Quadtree 등) 도입 → 불필요한 검사 감소 (O(n log n))            |
| **재측정** | 동일 seed·시나리오로 성능 개선 효과 정량 검증                            |

<br/>
<br/>

---

<br/>
<br/>

## 기대 결과

| 항목                               | 기대 효과                                      |
| ---------------------------------- | ---------------------------------------------- |
| **측정의 일관성 확보**             | Seed 기반 생성으로 재현 가능한 성능 비교       |
| **병목 지점 가시화**               | 프로파일링 데이터로 모듈별 비중 명확화         |
| **정량적 개선 검증**               | 개선 전후 성능 차이를 수치로 증명 가능         |
| **지속 가능한 최적화 사이클 구축** | “측정 → 분석 → 개선 → 검증”의 자동화 루프 확립 |

#### TODO

- profiler.ts 구현 및 seed 기반 그래프 생성 코드 반영
- 프로파일링 데이터 수집 스크립트 작성
- 분석 및 시각화 도구 (예: Python pandas + matplotlib) 연동
- 개선 대상 모듈별 성능 리포트 작성 및 개선 주기화
